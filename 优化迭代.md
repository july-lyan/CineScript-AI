## 目标
- 支持可上线的部署发布能力：免费 3 次，超出后按次付费（¥9.9/次），使用国内聚合支付（微信/支付宝），支付成功后用付费 Key 调用生成。
- 隐藏管理员/Dev 开关：仅本地 Mac（localhost/127.0.0.1）访问时才显示，其余环境不露出。
- 后端提供安全的模型调用与支付回调，实现前后端分离且不暴露 API Key。

## 需求拆解
- 免费额度：前端显示“免费 3 次”，计数保存在后端会话或前端 + 服务端校验。超出弹出支付。
- 付费模式：按次购买（默认 1 次 ¥9.9，可扩展多次包）。支付成功增加可用次数或直接标记为付费。
- 模型调用：
  - 免费：使用免费 Key/低配模型或限频。
  - 付费：使用付费 Key（单独提供），调用频率需参考官方文档并在后端限流。
- 支付：聚合支付（微信/支付宝）创建订单，返回二维码/唤起参数；服务端主动/被动查询支付结果，确认后写订单并发放额度。
- 可见性：Dev/管理员开关仅在本地 Mac（userAgent 包含 Macintosh 且 host 为 localhost/127.0.0.1/::1）显示。

## 推荐后端栈与部署
- 轻量推荐：Node.js 20 + Express/NestJS
  - 优点：与当前前端同栈；丰富的支付 SDK/聚合支付接口；易上手。
  - 部署：Vercel/Netlify Functions（需国内可访问域名时建议自有云）、阿里云函数/腾讯云 SCF、或 Docker 部署到云主机。
- 更健壮方案：Go + Gin
  - 优点：高性能并发、二进制易部署；国内云原生支持好。
- 如需 Java 生态：Spring Boot（配合支付 SDK 完整，但启动与资源占用较高）。
- 建议：先用 Node.js + NestJS/Express 快速落地；若有高并发再迁移 Go。

## 后端接口设计（示例）
- `POST /api/pay`：创建订单
  - 入参：`count`（购买次数，默认 1）、`channel`（wechat/alipay）。
  - 出参：`orderId`、`qrUrl` 或小程序/JSAPI 参数。
- `GET /api/pay/status?orderId=`：查询支付状态
  - 出参：`status` (pending/success/failed)、`paidCount`。
- `POST /api/pay/callback`：支付平台回调
  - 验签后更新订单状态，增加用户额度。
- `POST /api/analyze?tier=free|paid`
  - 逻辑：根据 tier 或用户剩余额度选用免费/付费 Key 调用模型；校验免费次数或扣减付费额度；返回生成结果。

## 支付流程（聚合支付）
1) 前端请求 `/api/pay`，获得 `orderId` + `qrUrl/params`；渲染二维码。
2) 前端轮询 `/api/pay/status`（或 WebSocket/SSE）确认成功。
3) 支付平台回调 `/api/pay/callback`，服务端验签并写库，标记订单成功并增加额度。
4) 前端收到成功后：关闭弹窗，更新剩余额度/付费状态，自动触发生成（使用付费 Key）。

## 前端改造要点
- 免费次数：`FREE_USAGE_LIMIT = 3`；状态包含 `credits`（已购未用次数）。
- 调用逻辑：
  - 若 `usageCount < 3` → 免费通道。
  - 否则若 `credits > 0` → 扣 1 直接调用付费通道。
  - 否则弹支付。
- 支付弹窗：展示“¥9.9/次”，点击调用 `/api/pay`，展示返回二维码，轮询 `/api/pay/status` 成功后 `setCredits(+1)`，`isPaid=true`，`handleAnalyze(true)`。
- Key 管理：前端不再直接用 `process.env`；统一调用后端 `/api/analyze`，由后端选择 free/paid Key。
- Dev/管理员开关：仅本地 Mac & localhost 显示；线上隐藏。

## 后端逻辑与安全
- Key 不下发前端；所有模型调用在后端完成。
- 按用户会话/登录态记录免费次数与付费额度，防刷防篡改（可用签名 Cookie + Redis）。
- 支付回调需验签、防重、防伪通知；订单状态幂等更新。
- 限流：基于 IP/用户的速率限制，避免滥用免费 Key；付费 Key 按官方频率配置。
- 日志与监控：记录订单、调用耗时与错误，便于排查。

## 技术执行拆解
1) 后端服务搭建
   - 选型 Node.js + Express/NestJS；配置环境变量：免费 Key、付费 Key、支付商户配置、回调 URL、DB/Redis 连接。
2) 支付聚合集成（易支付为例）
   - 创建订单：`/api/pay` 代理易支付下单，携带商户号/签名，生成 `orderId`、二维码 URL（或返回 code_url）。
   - 查询：`/api/pay/status` 查询易支付订单状态（或读取本地订单表）。
   - 回调：`/api/pay/callback` 验签（易支付 sign），校验金额、商户号、订单号、防重入；更新订单成功并增加额度；返回 `success` 文本。
   - 资金路径：用户→微信/支付宝→易支付代收→结算至你的银行卡/支付宝（按易支付的结算规则/周期）。
   - 安全：限制回调来源 IP/签名校验；记录回调日志，防重放；订单状态机幂等。
3) 模型代理接口
   - `/api/analyze`：路由层校验额度 → 选择 free/paid Key → 调用模型 → 返回结果。
   - 失败/限流时返回友好错误，前端展示。
4) 前端更新
   - 免费次数改 3；新增 `credits` 状态；支付弹窗改为“按次 ¥9.9”并调用后端支付接口。
   - 调用逻辑改为统一走 `/api/analyze`；成功扣减额度。
   - Dev/管理员开关：仅本地 Mac & localhost 显示。
   - 移除 `index.html` 重复引入的 `index.tsx`。
5) 测试
   - 单元：后端订单状态机、验签、额度扣减；前端计数与分支。
   - 集成：支付创建→回调→额度发放→付费调用。
   - 回归：免费 3 次、无 Key 暴露、暗管按钮隐藏。
6) 部署
   - 配置域名与 HTTPS；支付回调域名与路径白名单。
   - 环境变量：FREE_KEY、PAID_KEY、PAY_MCH_ID、PAY_KEY、DB/REDIS。
   - 监控与日志：调用/订单/错误告警。

## 风险与注意
- 支付回调需公网可达且与支付平台备案域名一致；注意时区/金额单位。
- 前端不得暴露 Key；避免将回调/查询放在前端直接可控的 URL 上允许越权。
- 频率限制以官方文档为准，后端需做限流与错误兜底。

## 模块化开发顺序（开发→自测→验收→发布）
1) 后端基础与模型代理  
   - 建骨架（Node.js + Express/NestJS）、环境变量、日志/错误处理、/health。  
   - 自测 mock Key；验收真/沙箱 Key 与限流；发布配置正式环境变量与阈值。
2) 额度与用户态  
   - 建额度模型（freeUsageCount、credits、isPaid）、会话/鉴权、扣减/发放幂等。  
   - 并发扣减自测；支付联动验收；发布启用 DB/Redis 持久化。
3) 支付聚合（易支付）  
   - `/api/pay` 下单返回 qrUrl；`/api/pay/status` 查询；`/api/pay/callback` 验签、防重、金额校验、状态机。  
   - 沙箱/本地模拟回调自测；小额真单验收；发布配置 notify_url、日志告警。
4) 前端支付与调用流  
   - 免费 3 次、credits 状态、支付弹窗“¥9.9/次”→ 调 `/api/pay` 渲染二维码→ 轮询 `/api/pay/status`；统一走 `/api/analyze`，成功扣减额度。  
   - 自测分支与错误提示；联调支付验收；发布构建并移除重复脚本引入。
5) 管理员/Dev 可见性  
   - 仅本地 Mac + localhost/127.0.0.1/::1 渲染；线上隐藏。  
   - 本地/灰度验证；随前端发布。
6) 监控与运维  
   - 指标：订单状态、回调成功率、模型调用成功率/耗时；告警：回调失败/验签失败/超时。  
   - 自测模拟异常；低流量验收；发布日志留存与告警。

